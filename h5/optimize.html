<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
    <main>
        <h3>前端优化</h3>
        1、从输入一个URL谈起 <br>
        2、DNS查询 <br>

        当你在浏览器中想访问 www.google.com 时，会通过进行以下操作：

            本地客户端向服务器发起请求查询 IP 地址
            查看浏览器有没有该域名的 IP 缓存
            查看操作系统有没有该域名的 IP 缓存
            查看 Host 文件有没有该域名的解析配置
            网络设备如路由器中查询缓存

            如果这时候还没得话，会通过直接去 DNS 根服务器查询，这一步查询会找出负责 com 这个一级域名的服务器
            然后去该服务器查询 google.com 这个二级域名
            接下来查询 www.google.com 这个三级域名的地址
            返回给 DNS 客户端并缓存起来
        <link rel="dns-prefetch" href="https://fonts.googleapis.com/"> <!-- 进行DNS预查询 当用到的时候就可以直接拿到对应的IP --> <br>
        3、建立HTTP(TCP)连接 <p>3次握手</p>

        HTTP1.0和HTTP1.1为了解决频繁的三次握手，可以在header中加入了Connection: Keep-Alive，keep-alive的连接会保持一段时间不断开，后续的请求都会复用这一条TCP，不过由于管道化的原因也会发生队头阻塞的问题。HTTP1.1默认开启Keep-Alive<br>
        <caption>
            队头阻塞
            一个tcp链接中的多个请求 如果前面的请求延迟返回 后面的所有链接都会延迟，即被阻塞。
            HTTP1.1进一步的优化在持久连接上使用管道化，同时发送多个http请求，但必须排队响应（按照请求的顺序）。依然存在局限性
            <ul>管道化的限制</ul>
            1、排队响应
            2、幂等请求
            由于这些限制 现代浏览器默认都关闭了管道化，并且大部分服务器也是默认不支持管道化的。
        </caption>
            HTTP2相对于HTTP1.1的一个主要升级是多路复用，多路复用通过更小的二进制帧构成多条数据流（帧和流），交错的请求和响应可以并行传输而不被阻塞，这样就解决了HTTP1.1时复用会产生的队头阻塞的问题
            <caption>
                1、帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。
                2、多路复用，就是在一个 TCP 连接中可以存在多条流
            </caption>
            同时HTTP2有首部压缩的功能，如果两个请求首部(headers)相同，那么会省去这一部分，只传输不同的首部字段，进一步减少请求的体积。Nginx开启HTTP2的方式特别容易，只需要加一句http2既可开启：
            <pre>
                server {
                 listen 443 ssl http2; # 加一句 http2.
                 server_name domain.com;
                }
            </pre>
        <i>
            TCP 协议是如何实现有序且完整的传递数据
            ARQ 协议也就是超时重传机制协议。通过确认和超时机制保证了数据的正确送达，其中包含停止等待 ARQ 和连续 ARQ 协议。
        </i>
        <p>
            拥塞处理包括了四个算法，分别为：慢开始，拥塞避免，快速重传，快速恢复。

            1.慢开始算法
            慢开始算法，顾名思义，就是在传输开始时将发送窗口慢慢指数级扩大，从而避免一开始就传输大量数据导致网络拥塞。举个例子在日常下载时，我们的下载网速都是逐渐变快的。
            慢开始算法步骤具体如下：

            连接初始设置拥塞窗口（Congestion Window） 为 1 MSS（一个分段的最大数据量）
            每过一个 RTT 就将窗口大小乘二
            指数级增长肯定不能没有限制的，所以有一个阈值限制，当窗口大小大于阈值时就会启动拥塞避免算法。

            2.拥塞避免算法
            拥塞避免算法相比简单点，每过一个 RTT 窗口大小只加一，这样能够避免指数级增长导致网络拥塞，慢慢将大小调整到最佳值。
            在传输过程中如果协议认为网络拥塞了，会马上进行以下步骤：

            将阈值设为当前拥塞窗口的一半
            将拥塞窗口设为 1 MSS
            启动拥塞避免算法

            3.快速重传
            快速重传一般和快恢复一起出现。一旦接收端收到的报文出现失序的情况，接收端只会回复最后一个顺序正确的报文序号（没有 Sack 的情况下）。如果收到三个重复的 ACK，说明发送端传过去的数据对端都没有收到，此时会启动快速重传。主要算法为：
            TCP Reno

            拥塞窗口减半
            将阈值设为当前拥塞窗口
            进入快恢复阶段（重发对端需要的包，一旦收到一个新的 ACK 答复就退出该阶段）
            使用拥塞避免算法

            4.TCP New Ren 改进后的快恢复
            TCP New Reno 算法改进了之前 TCP Reno 算法的缺陷。在之前，快恢复中只要收到一个新的 ACK 包，就会退出快恢复。
            在 TCP New Reno 中，TCP 发送方先记下三个重复 ACK 的分段的最大序号。
            假如我有一个分段数据是 1 ~ 10 这十个序号的报文，其中丢失了序号为 3 和 7 的报文，那么该分段的最大序号就是 10。发送端只会收到 ACK 序号为 3 的应答。这时候重发序号为 3 的报文，接收方顺利接收并会发送 ACK 序号为 7 的应答。这时候 TCP 知道对端是有多个包未收到，会继续发送序号为 7 的报文，接收方顺利接收并会发送 ACK 序号为 11 的应答，这时发送端认为这个分段接收端已经顺利接收，接下来会退出快恢复阶段。
        </p>
        <p>成本低廉，效果巨大。HTTP2</p>
        <p>
            HTTPS协议 HTTP协议 + TLS安全协议

            TLS 中使用了两种加密技术，分别为：对称加密和非对称加密。

            1、对称加密： 对称加密就是两边拥有相同的秘钥，两边都知道如何将密文加密解密。
            2、非对称加密： 有公钥私钥之分，公钥所有人都可以知道，可以将数据用公钥加密，但是将数据解密必须使用私钥解密，私钥只有分发公钥的一方才知道。

            TSL的握手
            <i>
                1客户端发送一个随机值，需要的协议和加密方式
                2服务端收到客户端的随机值，自己也产生一个随机值，并根据客户端需求的协议和加密方式来使用对应的方式，发送自己的证书（如果需要验证客户端证书需要说明）
                客户端收到服务端的证书并验证是否有效，验证通过会再生成一个随机值，通过服务端证书的公钥去加密这个随机值并发送给服务端，如果服务端需要验证客户端证书的话会附带证书
                服务端收到加密过的随机值并使用私钥解密获得第三个随机值，这时候两端都拥有了三个随机值，可以通过这三个随机值按照之前约定的加密方式生成密钥，接下来的通信就可以通过该密钥来加密解密
            </i>
        </p>
        4、HTTP缓存主要分为两种，一种是强缓存，另一种是协商缓存，都通过Headers控制 <br>
        强缓存根据请求头的Expires和Cache-Control判断是否命中强缓存 <br>
        服务器响应中会携带ETag和Last-Modified，Last-Modified <br>
        协商缓存比强缓存稍慢，因为还是会发送请求到服务器进行确认。 <br>
        CDN会把源站的资源缓存到CDN服务器，当用户访问的时候就会从最近的CDN服务器拿取资源而不是从源站拿取，这样做的好处是分散了压力，同时也会提升返回访问速度和稳定性 <br>

        5、压缩  合理的压缩资源可以有效减少传输体积，减少传输体积的结果就是用户更快的拿到资源开始解析 <br>
        浏览器在发起请求时会在headers中携带accept-encoding: gzip, deflate, br，告知服务器客户端可以接受的压缩算法，之后响应资源会在响应头中携带content-encoding: gzip告知本文件的压缩算法。 <br>
        GZIP是非常常用的压缩算法，现代客户端都会支持，你可以在上传文件时就上传一份压缩后的文件，也可以让Nginx动态压缩。 <br>

        6、进行页面渲染 <br>
        关键渲染路径是浏览器将HTML/CSS/JS转换为屏幕上看到的像素内容所经过的一系列步骤。浏览器得到HTML后会开始解析DOM树，CSS资源的下载不会阻塞解析DOM，但是也要注意，如果CSS未下载解析完成是会阻塞最终渲染的。从Performance面板中可以清晰的看到浏览器如何解析HTML的 <br>
        得到HTML后首先会解析HTML，然后解析样式，计算样式，绘制图层等等操作，JS脚本运行，之后可能会重复这一步骤。 <br>

        <ul>
            <h4>在这里前端可以做的事情多了起来，接下来自顶向下说起。渲染页面</h4>
            <li>
                1、预加载/预连接内容
                和前面说的DNS预查询一样，可以将即将要用到的资源或者即将要握手的地址提前告知浏览器让浏览器利用还在解析HTML计算样式的时间去提前准备好。
                使用link的preload属性预加载一个资源。 as属性可以指定预加载的类型，除了style还支持很多类型，常用的一般是style和script，css和js。其他的类型可以查看文档:preload
                <pre>
                <link rel="preload" href="style.css" as="style">
                </pre>
                prefetch <br>
                prefetch和preload差不多，prefetch是一个低优先级的获取，通常用在这个资源可能会在用户接下来访问的页面中出现的时候。当然对当前页面的要用preload，不要用prefetch，可以用到的一个场景是在用户鼠标移入a标签时进行一个prefetch。prefetch <br>
                preconnect <br>
                preconnect和dns-prefetch做的事情类似，提前进行TCP，SSL握手，省去这一部分时间，基于HTTP1.1(keep-alive)和HTTP2(多路复用)的特性，都会在同一个TCP链接内完成接下来的传输任务。 <br>
                2、 将script放在文档底部，尽可能推后脚本的执行时机，不过并不完全可控。时至今日，我们可以给script标签增加标记，使其异步(延迟)运行，把可控权交给开发者。 <br>
                async标记 async的好处是让多条js不会互相等待，下载期间浏览器会去干其他事(继续解析HTML等)，异步下载，异步执行。<br>
                defer标记告诉浏览器在等待js下载期间可以去干其他事，多条js可以并行下载，不过当js下载完成之后不会立即执行，而是会等待解析完整个HTML之后在开始执行，而且多条defer标记的js会按照顺序执行 <br>
                3、视窗外的内容懒加载  <br>
                4、减少无意义的回流 <br>
                5、 图片视频选择合理的尺寸 <br>
                6、 Tree-shaking指的是消除没被引用的模块代码，减少代码体积大小，以提高页面的性能，最初由rollup提出  很多打包工具都已支持。 如 webpack <br>
                7、压缩 <br>
                8、使用动态import()代替静态import做条件渲染的懒加载 vue-router文档中关于路由懒加载 <br>
                9、利用服务器端优先渲染出某一部分重要的内容，让其他内容懒加载，这样到达浏览器端时一部分HTML已经存在，页面上就可以呈现出一定的内容，这里注意服务器端渲染出来的HTML部分最好不要超过14kb，TCP慢开始的规则让第一个TCP包的大小是14kb，这是与网站交互会接受到的第一个包。 <br>
            </li>
        </ul>
        7、请求资源传输完之后 四次挥手来断开连接

          为什么 A 要进入 TIME-WAIT 状态，等待 2MSL 时间后才进入 CLOSED 状态？
          为了保证 B 能收到 A 的确认应答。若 A 发完确认应答后直接进入 CLOSED 状态，如果确认应答因为网络问题一直没有到达，那么会造成 B 不能正常关闭。

    </main>
    <main>
        <h3>优化标准的参考值</h3>
        <ul>
            <li>页面初载时，所有未压缩的 JavaScript 脚本大小：<b>&lt;=200KB</b>；</li>
            <li>页面初载时，所有未压缩的 CSS 资源大小：<b>&lt;=100KB</b>；</li>
            <li>HTTP 协议下，请求资源数：<b>&lt;=6 个</b>；</li>
            <li>HTTP/2 协议下，请求资源数：<b>&lt;=20 个</b> ；</li>
            <li><b>90%</b> 的代码利用率（也就是说，仅允许 10% 的未使用代码）；</li>
        </ul>
    </main>
</html>